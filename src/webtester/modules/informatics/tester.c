/**
 * WebTester Server - server of on-line testing system
 *
 * Testing module for simple olympiands
 *
 * Copyright 2008 Sergey I. Sharybin <g.ulairi@gmail.com>
 *
 * This program can be distributed under the terms of the GNU GPL.
 * See the file COPYING.
 */

#include "informatics.h"
#include "macros.h"

#include <libwebtester/smartinclude.h>
#include <libwebtester/dynastruc.h>
#include <libwebtester/conf.h>
#include <libwebtester/flexval.h>
#include <libwebtester/strlib.h>
#include <libwebtester/regexp.h>
#include <libwebtester/util.h>
#include <libwebtester/fs.h>
#include <libwebtester/mutex.h>

#include <testlib/testlib.h>

#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>

#include "saferun.h"

/* MAX count of tests */
#define MAX_TESTS      1024
#define MAX_ERRCODE    2

#define MAX_COMPILER_MSG_LEN 4096

/* File to print solution's testing info */
#define SOLUTION_ERRORS_LOG "errors.log"

/****
 * Macroses
 */

/* Check module's active in testing loop */
#define LOOP_CHECK_ACTIVE \
  if (mutex_trylock (active)) \
    { \
      mutex_unlock (active); \
      goto __done_; \
    }

/* Check module's active after testing loop */
#define LOOP_DONE_CHECK_ACTIVE \
  if (mutex_trylock (active)) \
    { \
      mutex_unlock (active); \
      /* Checking has been interrupted. */ \
      /* So there is nothing interesting in testing dir. */ \
      unlinkdir (__cur_testing_dir); \
      return; \
    }

/* Check module's active in main testing thread */
#define TESTING_CHECK_ACTIVE \
  if (mutex_trylock (active)) \
    { \
      mutex_unlock (active); \
      goto __free_; \
    }

#ifdef INFORMATICS_ENABLE_REPORT
#  define REPORT(__params,__text,__args...) \
  { \
    char sbuf[4096], buf[4096]; \
    snprintf (buf, BUF_SIZE (buf), __text, ##__args); \
    strcpy (sbuf, ""); \
    if (assarr_get_value (__params, "REPORT")) \
      { \
        strcat (sbuf, assarr_get_value (__params, "REPORT")); \
        assarr_unset_value (__params, "REPORT", assarr_deleter_free_ref_data); \
      } \
    strcat (sbuf, buf); \
    assarr_set_value (__params, "REPORT", strdup (sbuf)); \
  }
#else
#  define REPORT(__params,__text,__args...)
#endif

#define TASK_SRCEXT(__self) \
  COMPILER_SAFE_PCHAR_KEY (TASK_COMPILER_ID (*__self), \
                           "Extension", INFORMATICS_SRCEXT)

#define STORE_OUTPUTS(__outputs, __param)               \
  if (__outputs != NULL) \
    { \
      char *pchar; \
 \
      assarr_pack (__outputs, &pchar); \
      assarr_set_value (__params, __param, pchar); \
      assarr_destroy (__outputs, assarr_deleter_free_ref_data); \
    }


/****
 *
 */

static char log_banner[] = "\
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\
 This file is automatically generated by module Informatics\n\
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n";

/****
 *
 */

static DWORD checker_memory_limit = INFORMATICS_CHECKER_RSS_LIMIT;
static DWORD checker_time_limit = INFORMATICS_CHECKER_TIME_LIMIT*MSEC_COUNT;
static GThreadPool *pool = NULL;
static GMutex *active = NULL;
static long max_threads = INFORMATICS_MAX_THREADS;

static char testing_dir[4096];
static char data_dir[4096];
static char problems_dir[4096];
static char source_file[4096];
static char file_to_exec[4096];

static char checker_cmd_template[4096];

static DWORD unlink_interval = INFORMATICS_UNLINK_INTERVAL*USEC_COUNT;
static long keep_alive_testdirs = INFORMATICS_KEEP_ALIVE_TESTDIRS;
static GMutex *unlink_mutex = NULL;

/* Extensions of input and output tests' filenames */
static char tst_ext[128];
static char ans_ext[128];

static BOOL use_chroot = FALSE;

static mutex_t suspended = 0;

static DWORD max_output_store_size = 0;

/* Mutex for lock-files operations */
static GMutex *lck_mutex = NULL;

/* Null-terminated list of required input task's params */
static char *required_params[] = {"SOURCE",
  "COMPILERID",
  "BONUS",
  "INPUTFILE",
  "OUTPUTFILE",
  "MEMORYLIMIT",
  "TIMELIMIT",
  "ACM",
  "TESTS",
  0};

static char chroot_items[64][64] = {
  {0}};

/****
 * Internal stuff
 */

/**
 * Copy all files needed for correct working after chrooting
 *
 * @param __dst_dir - where files should be copied
 */
static void
copy_chroot_data (const char *__dst_dir)
{
  char src_dir[4096];
  static char init = FALSE;

  INF_DEBUG_LOG ("Copying chroot data to %s\n", __dst_dir);

  snprintf (src_dir, BUF_SIZE (src_dir), "%s/chroot", data_dir);
  fcopydir (src_dir, __dst_dir);

  snprintf (src_dir, BUF_SIZE (src_dir), "%s/chroot", data_dir);

  if (!init)
    {
      /* Cache list of items, needed by chrooting */
      dynastruc_t *ls;
      int count = 0;
      char *cur_dir;
      ls = dir_listing (src_dir);

      DYNA_FOREACH (ls, cur_dir);
        strcpy (chroot_items[count++], cur_dir);
      DYNA_DONE;

      dyna_destroy (ls, dyna_deleter_free_ref_data);
      init = TRUE;
    }
}

/**
 * Remove all files needed for correct working after chrooting
 * from solution directory
 *
 * @param __dir - where files should be deleted
 */
static void
remove_chroot_data (const char *__dir)
{
  int i = 0;
  char full[4096];

  INF_DEBUG_LOG ("Removing chroot data from %s\n", __dir);

  while (chroot_items[i][0])
    {
      snprintf (full, BUF_SIZE (full), "%s/%s", __dir, chroot_items[i]);
      unlinkdir (full);
      i++;
    }
}

/**
 * Push string to another separating from existing content
 *
 * @param __item - item to be pushed
 * @param __delimeter - separator of items
 * @param __buf - output buffer
 */
static void
push_string (const char *__item, const char *__delimeter, char *__buf)
{
  if (strcmp (__buf, ""))
    {
      strcat (__buf, __delimeter);
    }
  strcat (__buf, __item);
}

/**
 * Replace default variables in string
 *
 * @param __str - string to be replaced
 * @param __cur_testing_dir - current testing directpry
 * @param __cur_data_dir - directpry with current data files
 */
static void
replace_defaults (char *__str, const char *__cur_testing_dir,
                  const char *__cur_data_dir)
{
  REPLACE_VAR (__str, "testing_dir", testing_dir);
  REPLACE_VAR (__str, "data_dir", data_dir);
  REPLACE_VAR (__str, "cur_testing_dir", __cur_testing_dir);
  REPLACE_VAR (__str, "cur_data_dir", __cur_data_dir);
}

/**
 * PChar-ed number of test
 *
 * @param __num - number of current test
 * @param __total - total count of tests
 * @param __buf - output buffer
 */
static void
testnum (int __num, int __total, char *__buf)
{
  if (__total < 100)
    {
      sprintf (__buf, "%02d", __num);
    }
  else
    {
      sprintf (__buf, "%03d", __num);
    }
}

/**
 * Save solution to file
 *
 * @param __self - testing task
 * @param __cur_testing_dir - current testing directory
 * @return TRUE if solution saved, FALSE otherwise
 */
static BOOL
save_solution (wt_task_t *__self, char *__cur_testing_dir)
{
  char fn[4096];
  char *src = TASK_INPUT_PARAM (*__self, "SOURCE");

  snprintf (fn, BUF_SIZE (fn), "%s/%s%s", __cur_testing_dir,
            source_file, TASK_SRCEXT (__self));

  /* Write data to stream */
  if (fwritebuf (fn, src))
    {
      INF_DEBUG_LOG ("Task %ld. Error writting buffer to solution file\n",
                     __self->sid);
      return FALSE;
    }

  chmod (fn, 00660);

  return TRUE;
}

/******
 * Compiling stuff
 */

/**
 * Get command to compile solution
 *
 * @param __self - task to be compoled
 * @param __cur_testing_dir - current testing directory
 * @param __cur_data_dir - directory with current data
 * @para, __cmd - output buffer
 */
static void
build_compiler_command (wt_task_t *__self, const char *__cur_testing_dir,
                        const char *__cur_data_dir, char *__cmd)
{
  char dummy[4096], flags[4096] = "", flags_path[1024];

  /* Get command from config file */
  strcpy (__cmd, COMPILER_PCHAR_KEY (TASK_COMPILER_ID (*__self), "Command"));

  snprintf (flags_path, BUF_SIZE (flags_path),
            "CompilerFlags/%s", TASK_COMPILER_ID (*__self));
  INF_PCHAR_KEY (flags, flags_path);

  /* Parse command */
  replace_defaults (__cmd, __cur_testing_dir, __cur_data_dir);
  REPLACE_VAR (__cmd, "flags", flags);

  /* Source filename */
  snprintf (dummy, BUF_SIZE (dummy), "%s%s", source_file, TASK_SRCEXT (__self));
  REPLACE_VAR (__cmd, "source", dummy);

  /* Output filename */
  snprintf (dummy, BUF_SIZE (dummy), "%s%s", file_to_exec,
            COMPILER_SAFE_PCHAR_KEY (TASK_COMPILER_ID (*__self),
                                     "OutputExtension", INFORMATICS_EXECEXT));
  REPLACE_VAR (__cmd, "output", dummy);
}

/**
 * Run compiler with profiling
 *
 * @paxram __self - task to be compiled
 * @param __cmd - command to execute
 * @param __cur_testing_dir - current testing directory
 * @param __cur_data_dir - directory with current data
 * @oaram __params - collecting params to return to WebIFACE
 * @return TRUE on success, FALSE otherwise
 */
static BOOL
run_compiler (wt_task_t *__self, const char *__cmd,
              const char *__cur_testing_dir, const char *__cur_data_dir,
              assarr_t *__params)
{
  DWORD compiler_ml, compiler_tl, common_compiler_ml, common_compiler_tl;
  
  /* Get compiler's limits */
  common_compiler_ml = COMPILER_SAFE_COMMON_INT_KEY ("Limits/RSS",
                                               INFORMATICS_COMPILER_RSS_LIMIT);
  common_compiler_tl = COMPILER_SAFE_COMMON_FLOAT_KEY ("Limits/Time",
                                              INFORMATICS_COMPILER_TIME_LIMIT);

  compiler_ml = COMPILER_SAFE_INT_KEY (TASK_COMPILER_ID (*__self),
                                       "Limits/RSS", common_compiler_ml);
  compiler_tl = COMPILER_SAFE_FLOAT_KEY (TASK_COMPILER_ID (*__self),
                               "Limits/Time", common_compiler_tl) * MSEC_COUNT;

  /* Create process */
  INF_DEBUG_LOG ("Task %ld. Executing compiler (cmd: %s)\n",
                 __self->sid, __cmd);

  struct saferun_params_t params;
  params.chroot = NULL;
  params.dir = __cur_testing_dir;
  params.memory_limit = compiler_ml;
  params.time_limit = compiler_tl;
  params.redirect_stdin = NULL;
  params.redirect_stdout = "compiler.log";
  params.redirect_stderr = "stdout";
  
  int res = saferun(__cmd, &params);
  
  INF_DEBUG_LOG ("Task %ld. Finish executing compiler\n", __self->sid);

  if (res == -1) {
      INF_DEBUG_LOG ("Task %ld. Executing compiler failed: ???\n",
                     __self->sid);
      TASK_LOG (*__self, "\n--------\n"
                         "Fatal error: error executing compiler: ???.\n"
                         "Testing aborted.\n");
      REPORT (__params, "Error executing compiler: ???.");
      return -1;
  }

  char compiler_log_fname[1024];
  snprintf(compiler_log_fname, 1024, "%s/compiler.log", __cur_testing_dir);
  
  char compiler_buf[MAX_COMPILER_MSG_LEN];
  FILE *compiler_log = fopen(compiler_log_fname, "r");
  size_t read_length = fread(compiler_buf, 1, MAX_COMPILER_MSG_LEN, compiler_log);
  fclose(compiler_log);
  
  if (read_length >= MAX_COMPILER_MSG_LEN) {
    compiler_buf[MAX_COMPILER_MSG_LEN - 4] = 0;
    strcat (compiler_buf, "...");
  } else {
    compiler_buf[read_length] = 0;
  }
  
  assarr_set_value (__params, "COMPILER_MESSAGES", strdup(compiler_buf));
  
  if (res == 0)
      return TRUE;
  else
      return FALSE;
}

/**
 * Checking, casted after running compiler
 *
 * @param __self - task to be compiled
 * @param __cur_testing_dir - current testing directory
 * @param __cur_data_dir - directory with current data
 * @oaram __params - collecting params to return to WebIFACE
 * @return TRUE on success, FALSE otherwise
 */
static BOOL
post_compiling_check (wt_task_t *__self, const char *__cur_testing_dir,
                      const char *__cur_data_dir, assarr_t *__params)
{
  char pchar[4096];

  /* Check for existment of solution executable file */
  /* Get full filename of executable file */
  snprintf (pchar, BUF_SIZE (pchar), "%s/%s%s", __cur_testing_dir, file_to_exec,
            COMPILER_SAFE_PCHAR_KEY (TASK_COMPILER_ID (*__self),
                                     "OutputExtension", ""));

  if (!fexists (pchar))
    {
      return FALSE;
    }

  chmod (pchar, 00775);

  return TRUE;
}

/**
 * Compile solution
 *
 * @param __self - task to be compiled
 * @param __cur_testing_dir - current testing directory
 * @param __cur_data_dir - directory with current data
 * @oaram __params - collecting params to return to WebIFACE
 * @return TRUE on success, FALSE or value less than zero in case of error
 */
static BOOL
compile_solution (wt_task_t *__self, const char *__cur_testing_dir,
                  const char *__cur_data_dir, assarr_t *__params)
{
  char cmd[32768];

  /* Generate command */
  strcpy (cmd, "");
  build_compiler_command (__self, __cur_testing_dir, __cur_data_dir, cmd);
  assarr_set_value (__params, "COMPILER_COMMAND", strdup (cmd));

  /* Compile command not defined */
  if (!strcmp (cmd, ""))
    {
      INF_DEBUG_LOG ("Task %ld. Compiler's command is undefined\n",
                     __self->sid);
      TASK_LOG (*__self, "\n--------\nFatal error: Compiler command is "
                         "undefined.\nTesting aborted.\n");
      REPORT (__params, "Compiler command is undefined.");

      return -1;
    }

  if (!run_compiler (__self, cmd, __cur_testing_dir, __cur_data_dir, __params))
    {
      return FALSE;
    }

  /* Some more checking */
  return post_compiling_check (__self, __cur_testing_dir,
                               __cur_data_dir, __params);
}

/**
 * Copy test to testing directory
 *
 * @param __num - number of test to copy
 * @param __total - total count of tests
 * @param __data_dir - data directory
 * @param __dst - destination directory
 * @param __name - name of file to store to
 * @return TRUE on success, FALSE otherwise
 */
static BOOL
copy_test (int __num, int __total, const char *__data_dir,
           const char *__dst, const char *__name)
{
  char src[4096], dst[4096], tst[16];

  /* Get full source filename */
  testnum (__num, __total, tst);
  snprintf (src, BUF_SIZE (src), "%s/%s%s", __data_dir, tst, tst_ext);

  /* Check for existment of test file */
  if (!fexists (src))
    {
      return FALSE;
    }

  /* Get full destination filename */
  snprintf (dst, BUF_SIZE (dst), "%s/%s", __dst, __name);

  if (copyfile (src, dst))
    {
      INF_DEBUG_LOG ("Error copuing test file from %s to %s\n", src, dst);
      return FALSE;
    }

  return TRUE;
}

/*
 * Build command to run checker
 *
 * @param __self - task to be compiled
 * @param __cur_testing_dir - current testing directory
 * @param __cur_data_dir - directory with current data
 * @param __test_num - number of curretn test
 * @para, __tests_count - count of tests
 * @return TRUE on success, FALSE otherwise
 */
static void
build_checker_cmd (wt_task_t *__self, const char *__cur_testing_dir,
                   const char *__cur_data_dir, int __test_num,
                   int __tests_count, char *__out)
{
  char atest[16]; /* PChar-ed number of test */
  char *input_file = TASK_INPUT_PARAM (*__self, "INPUTFILE");
  char *output_file = TASK_INPUT_PARAM (*__self, "OUTPUTFILE");

  testnum (__test_num, __tests_count, atest);

  strcpy (__out, checker_cmd_template);

  replace_defaults (__out, __cur_testing_dir, __cur_data_dir);

  REPLACE_VAR (__out, "test", atest);
  REPLACE_VAR (__out, "input_file", input_file);
  REPLACE_VAR (__out, "output_file", output_file);
}

/****
 *
 */

static BOOL
need_store (const char *__param)
{
  int i;
  flex_value_t *retprops = NULL;
  char *pchar;

  CONFIG_OPEN_KEY (retprops, "Server/Modules/Informatics/RetProps");

  for (i = 0; i < FLEXVAL_ARRAY_LENGTH (retprops); i++)
    {
      pchar = flexval_get_array_string (retprops, i);
      if (!strcmp (pchar, __param))
        {
          return TRUE;
        }
    }

  return FALSE;
}

/**
 * Check if storing of solution's output is needed
 *
 * @return non-zero if storing is needed, zero otherwise
 */
static BOOL
need_store_output (void)
{
  static BOOL initialized = FALSE;
  static BOOL result = FALSE;

  if (!initialized)
    {
      result = need_store ("SOLUTION_OUTPUT");
      initialized = TRUE;
    }

  return result;
}

/**
 * Check if storing of checker's output is needed
 *
 * @return non-zero if storing is needed, zero otherwise
 */
static BOOL
need_store_checker_output (void)
{
  static BOOL initialized = FALSE;
  static BOOL result = FALSE;

  if (!initialized)
    {
      result = need_store ("CHECKER_OUTPUT");
      initialized = TRUE;
    }

  return result;
}

static char *
make_run_solution_cmd(wt_task_t *__self, const char *__cur_data_dir,
                   const char *__cur_testing_dir) {
  /* Filename to execute */
  char execfn[4096] = {0};

    /* Get command for solution executing */
  char *run_solution_cmd = COMPILER_SAFE_PCHAR_KEY (TASK_COMPILER_ID (*__self),
                                                    "RunSolutionCmd", NULL);

  if (run_solution_cmd && strcmp (run_solution_cmd, "")) {
      /* We'll make some changes in this string, so we should */
      /* close this string to make original stored in hive tree */
      /* for correct freeing */
      run_solution_cmd = strdup (run_solution_cmd);

      /* String may be enlarged when parameters will be substitued  */
      run_solution_cmd = realloc (run_solution_cmd, 65535);

      replace_defaults (run_solution_cmd, __cur_testing_dir, __cur_data_dir);
  }

    /* Get executable file name */
  INF_PCHAR_KEY (execfn, "FileToExec");
  strcat (execfn, COMPILER_SAFE_PCHAR_KEY (TASK_COMPILER_ID (*__self),
                                           "OutputExtension", ""));
  if (run_solution_cmd) {
      REPLACE_VAR (run_solution_cmd, "executable", execfn);
  } else {
      char RUN_SOLUTION_CMD_BUF[1024];
      snprintf(RUN_SOLUTION_CMD_BUF, 1024, "./%s", execfn);
      run_solution_cmd = strdup (RUN_SOLUTION_CMD_BUF);
  }
  
  return run_solution_cmd;
}

static int task_get_tests(wt_task_t *__self, int *tests) {
    /* Unpack tests' data */
  char *tests_pchar = TASK_INPUT_PARAM (*__self, "TESTS"),
          effective_tests[4096];

  char **tests_pchar_arr = 0;

  /*
   * TODO: Need to strip dupicated spaces in source string with tests
   */

  trim (tests_pchar, effective_tests);
  int tests_count = explode (effective_tests, " ", &tests_pchar_arr);

  int i;
  for (i = 0; i < tests_count; i++)
    tests[i] = atoi (tests_pchar_arr[i]);

  /* Free unwanted data */
  free_explode_data (tests_pchar_arr);

  return tests_count;
}

typedef struct testing_task_t {
	wt_task_t *self;
	int sid;
	const char *cur_data_dir;
	const char *cur_testing_dir;
	char *run_solution_cmd;

	int tests[MAX_TESTS];
	int tests_count;
	int bonus;

	BOOL acm;

	char *input_file;
	char *output_file;

	DWORD memory_limit;
	DWORD time_limit;

    char full_input[4096];
	char full_output[4096];

	BOOL use_chroot;
} testing_task_t;


int testing_run_solution(const testing_task_t *task) {
	/* Execute solution */
	INF_DEBUG_LOG("Task %ld. Executing solution (cmd: %s)\n", task->sid,
			task->run_solution_cmd);

	saferun_params_t srun_params;
	if (use_chroot) {
		srun_params.chroot = task->cur_testing_dir;
		srun_params.dir = "/";
	} else {
		srun_params.chroot = NULL;
		srun_params.dir = task->cur_testing_dir;
	}
	srun_params.memory_limit = task->memory_limit;
	srun_params.time_limit = task->time_limit;
	srun_params.redirect_stdin = task->input_file;
	srun_params.redirect_stdout = "stdout.log";
	srun_params.redirect_stderr = "stdout";

	int result = saferun(task->run_solution_cmd, &srun_params);

    INF_DEBUG_LOG ("Task %ld. Finish executing solution\n", task->sid);
    return result;
}

testing_task_t testing_task_from_wt_task(wt_task_t *__self, const char *__cur_data_dir,
        const char *__cur_testing_dir) {

	testing_task_t task;
	task.self = __self;
	task.sid = __self->sid;
	task.cur_data_dir = __cur_data_dir;
	task.cur_testing_dir = __cur_testing_dir;

	/* Tests */
	task.tests_count = task_get_tests(__self, task.tests);

	/* Bonus points (if all tests passed) */
	task.bonus = atoi (TASK_INPUT_PARAM (*__self, "BONUS"));

	/* I/O filenames  */
	task.input_file = TASK_INPUT_PARAM (*__self, "INPUTFILE");
	task.output_file = TASK_INPUT_PARAM (*__self, "OUTPUTFILE");

    /* Full too */
	snprintf (task.full_input, BUF_SIZE (task.full_input), "%s/%s",
	            __cur_testing_dir, task.input_file);
	snprintf (task.full_output, BUF_SIZE (task.full_output), "%s/%s",
	            __cur_testing_dir, task.output_file);

	/* ACM? */
	task.acm = !strcmp (TASK_INPUT_PARAM (*__self, "ACM"), "TRUE");

	/* Run solution command */
	task.run_solution_cmd = make_run_solution_cmd(__self, __cur_data_dir, __cur_testing_dir);

	/* Use chroot? */
	int compiler_chroot = COMPILER_SAFE_INT_KEY (TASK_COMPILER_ID (*__self),
	                                              "ChRoot", -1);
	if (compiler_chroot >= 0)
		task.use_chroot = compiler_chroot;
	else
		task.use_chroot = use_chroot;

	/* Resource limits */
	/* But why simple atof doesn't work? */
	task.memory_limit = flexval_atolf (TASK_INPUT_PARAM (*__self,
	                                             "MEMORYLIMIT")) * 1024; /* Kb */
	task.time_limit = flexval_atolf (TASK_INPUT_PARAM (*__self,
	                                        "TIMELIMIT")) * MSEC_COUNT; /* msecs */

	/* Get corrections to apply when executing solution */
	double time_corr, rss_corr;
	char dummy[1024];
	snprintf (dummy, BUF_SIZE (dummy), "ResourceCorrections/Compilers/%s/Time",
	          TASK_COMPILER_ID (*__self));
	INF_SAFE_FLOAT_KEY (time_corr, dummy, 0);

	snprintf (dummy, BUF_SIZE (dummy), "ResourceCorrections/Compilers/%s/RSS",
	          TASK_COMPILER_ID (*__self));
	INF_SAFE_FLOAT_KEY (rss_corr, dummy, 0);

    if (fabs (time_corr) > 1e-8 || fabs (rss_corr) > 1e-8) {
	      INF_DEBUG_LOG ("Using per-compiler corrections: RSS: %lf, time: %lf\n",
	                     rss_corr, time_corr);
	}

	/* Apply corrections */
	task.time_limit += time_corr * MSEC_COUNT;
	task.memory_limit += rss_corr;

	return task;
}

static int testing_run_checker(const testing_task_t *task, const int i,
		assarr_t *checker_outputs, assarr_t *__params) {
  char checker_cmd[4096];
  build_checker_cmd (task->self, task->cur_testing_dir, task->cur_data_dir,
					 i + 1, task->tests_count, checker_cmd);

  char checker_log[1024];
  snprintf(checker_log, 1024, "%s/checker.log", task->cur_testing_dir);

  /* Process's descriptor */
  INF_DEBUG_LOG ("Task %ld. Executing checker (cmd: %s)\n",
				 task->sid, checker_cmd);

  saferun_params_t srun_params;
  srun_params.chroot = NULL;
  srun_params.dir = task->cur_data_dir;
  srun_params.memory_limit = checker_memory_limit;
  srun_params.time_limit = checker_time_limit;
  srun_params.redirect_stdin = NULL;
  srun_params.redirect_stdout = checker_log;
  srun_params.redirect_stderr = "/dev/null";

  int result = saferun(checker_cmd, &srun_params);

  INF_DEBUG_LOG ("Task %ld. Finish executing checker\n",
				 task->sid);

  /* Error while trying to execute checker */
  if (result == -1) {
	  INF_DEBUG_LOG ("Task %ld. "
					 "Fatal error during executing checker: ??\n",
					 task->sid);

	  TASK_LOG (*task->self, "\n--------\n"
						 "Fatal error: error executing checker "
						 "at test #%d: ??.\nTesting aborted.\n",
				i + 1);

	  REPORT (__params, "Error executing checker at test #%d: ??.",
			  i + 1);

	  return TESTING_SC;
  }

  /* Resource usage error while executing checker */
  if (result == TESTING_ML || result == TESTING_TL) {
	  INF_DEBUG_LOG ("Task %ld. "
					 "Checker's resource usage error (%s)\n",
					 task->sid, (result == TESTING_ML) ?
									   ("Memory limit") :
									   ("Time limit"));

	  TASK_LOG (*task->self, "\n--------\n"
						 "Fatal error: resource limit error while "
						 "executing checker.\nTesting aborted.\n");
	  REPORT (__params, "Resource limit exceeded while executing "
						"checker at test #%d. ",
			  i + 1);

	  return TESTING_SC;
  }

  /* Checker finished by signal. */
  if (!srun_params.exited) {
	  TASK_LOG (*task->self, "\n--------\n"
						 "Fatal error: Abnormal checker "
						 "termination at test #%d. "
						 "TERM signal: %d.\nTesting aborted.\n",
				i + 1, WTERMSIG(srun_params.status));

	  REPORT (__params, "Abnormal checker termination at test #%d. "
						"TERM signal: %d.", i + 1, WTERMSIG(srun_params.status));

	  return TESTING_SC;
  }

  INF_DEBUG_LOG ("Task %ld. "
				 "Checker finished working with exit code %d\n",
				 task->sid, srun_params.exit_code);


  /* Store checker's output message */
  if (checker_outputs) {
	  char dummy[10];
	  snprintf (dummy, BUF_SIZE (dummy), "%d", i);

	  char checker_buf[1024];
	  FILE *log = fopen(checker_log, "r");
	  size_t read_length = fread(checker_buf, 1, BUF_SIZE(checker_buf) - 1, log);
	  checker_buf[read_length] = 0;
	  fclose(log);

	  assarr_set_value (checker_outputs, dummy, strdup (checker_buf));
  }

  int res = TESTING_SC;
  /* Overview checker's exit code */
  switch (srun_params.exit_code) {
	case _OK:
	  res = TESTING_OK;
	  break;
	case _WA:
	  res = TESTING_WA;
	  break;
	case _PE:
	  res = TESTING_PE;
	  break;
  }

  if (res == TESTING_SC) {
	 /* Unknown checker's exit code */
	 TASK_LOG (*task->self, "\n--------\nFatal error: checker exited "
						 "with unknown code: %d.\nTesting aborted.\n",
						 srun_params.exit_code);

	 REPORT (__params, "Checker exited with unknown code: %d\n",
						srun_params.exit_code);
  }

  return res;
}

static int testing_run_test(const testing_task_t *task, const int i,
		                    assarr_t *outputs, assarr_t *checker_outputs, assarr_t *__params)
{

    /* Copy test file (input file) */
    INF_DEBUG_LOG ("Task %ld. Copy test\n", task->sid);
    if (!copy_test (i + 1, task->tests_count, task->cur_data_dir,
                    task->cur_testing_dir, task->input_file)) {
        TASK_LOG (*task->self, "\n--------\n"
                           "Fatal error: error copying test file #%d.\n"
                           "Testing aborted.\n", i + 1);
        REPORT (__params, "Error copying test #%d.", i + 1);

        return TESTING_SC;
    }

	/* Execute solution */
	int res = testing_run_solution(task);

	if (res == -1 || res == TESTING_SC || res == TESTING_SV) {
        INF_DEBUG_LOG ("Task %ld. "
                       "Some fatal error during executing solution\n",
                       task->sid);

        TASK_LOG (*task->self, "\n--------\n"
                           "Fatal error: error executing solution "
                           "at test #%d.\nTesting aborted.\n",
                  i + 1);

        REPORT (__params, "Error executing solution at test #%d.",
                i + 1);

        return TESTING_SC;
    }

    if (res != TESTING_OK)
    	return res;

    if (!fexists (task->full_output)) {
		/* No output file. Presentation error. */
		INF_DEBUG_LOG ("Task %ld. Output file not found after "
				 "running solution.", task->sid);

		return TESTING_PE;
    }

    if (outputs) {
    	char output[max_output_store_size + 1];
    	FILE *stream = fopen (task->full_output, "r");

    	char test[10];
		snprintf (test, BUF_SIZE (test), "%d", i);

		if (stream) {
			size_t len = fread (output, 1, max_output_store_size, stream);
			output[len] = 0;
			assarr_set_value (outputs, test, strdup (output));
			fclose (stream);
	    }
	}

    return testing_run_checker(task, i, checker_outputs, __params);
}

/*
 * Main stuff of testing
 *
 * @param __self - task to be compiled
 * @param __cur_testing_dir - current testing directory
 * @param __points - collected points
 * @param __errors - solution's errors on tests
 * @oaram __params - collecting params to return to WebIFACE
 */
static void
testing_main_loop (wt_task_t *__self, const char *__cur_data_dir,
                   const char *__cur_testing_dir, int *__points,
                   char *__errors, assarr_t *__params)
{
  INF_DEBUG_LOG ("Task %ld. Enter testing mainloop stuff\n", __self->sid);

  /* String with all tests' results */
  char tests_res_pchar[(MAX_ERRCODE + 1) * MAX_TESTS];

  /* Errors */
  BOOL errors[TESTING_RESULT_COUNT];
  memset(errors, 0, sizeof(errors));

  assarr_t *outputs = NULL, *checker_outputs = NULL;

  testing_task_t task = testing_task_from_wt_task(__self, __cur_data_dir, __cur_testing_dir);
  TASK_LOG (*__self, "----\n");

  /* Copying all libs/binaries needed for correct running of solution */
  if (task.use_chroot)
      copy_chroot_data (__cur_testing_dir);

  if (need_store_output () && max_output_store_size > 0)
      outputs = assarr_create ();

  if (need_store_checker_output ())
      checker_outputs = assarr_create ();

  /* Cycle by tests */
  INF_DEBUG_LOG ("Task %ld. Begin cycle by tests\n", __self->sid);
  int i;
  for (i = 0; i < task.tests_count; i++)
    {
      LOOP_CHECK_ACTIVE;

      int result = testing_run_test(&task, i, outputs, checker_outputs, __params);

      /* Delete input file (to reduce storaging of garbage) and */
      /* correct handling of PE */
      unlink (task.full_input);
      unlink (task.full_output);

      push_string (testing_result_to_str[result], " ", tests_res_pchar);

      TASK_LOG (*__self, "  Test #%d: %s\n", i+1, testing_result_to_str[result]);

      if (result == TESTING_SC)
    	  break;

      if (result == TESTING_OK)
    	  (*__points) += task.tests[i];
      else
    	  errors[result] = TRUE;

      if (task.acm && result != TESTING_OK)
    	  break;
    }

  INF_DEBUG_LOG ("Task %ld. Testing mainloop finished\n", __self->sid);

__done_:

  SAFE_FREE (task.run_solution_cmd);
  assarr_set_value (__params, "TESTS", strdup (tests_res_pchar));

  if (task.use_chroot)
      remove_chroot_data (__cur_testing_dir);

  LOOP_DONE_CHECK_ACTIVE;

  if (!errors[TESTING_SC]) {
      if (errors[TESTING_RE]) push_string ("RE", " ", __errors);
      if (errors[TESTING_ML]) push_string ("ML", " ", __errors);
      if (errors[TESTING_TL]) push_string ("TL", " ", __errors);
      if (errors[TESTING_WA]) push_string ("WA", " ", __errors);
      if (errors[TESTING_PE]) push_string ("PE", " ", __errors);

      /* If errors' string is empty, no errors were occured */
      /* in task's testing. So we can set bonus to points. */
      if (!strcmp (__errors, ""))
        {
          (*__points) += task.bonus;
          strcpy (__errors, "OK");
        }
  } else {
	  strcpy (__errors, "CR");
	  (*__points) = 0;
  }

  STORE_OUTPUTS (outputs,         "SOLUTION_OUTPUT");
  STORE_OUTPUTS (checker_outputs, "CHECKER_OUTPUT");
}

/**
 * Set task's output parameters
 *
 * @param __task - task to set parameters to
 * @param __params - params to use
 */
static void
set_output_params (wt_task_t *__task, assarr_t *__params)
{
  int i;
  char *pchar;
  flex_value_t *retprops = NULL;

  /*
   * TODO: Need beautiful solution to solve this query
   */

  CONFIG_OPEN_KEY (retprops, "Server/Modules/Informatics/RetProps");
  if (!retprops)
    {
      return;
    }

  for (i = 0; i < FLEXVAL_ARRAY_LENGTH (retprops); i++)
    {
      pchar = flexval_get_array_string (retprops, i);
      if (assarr_get_value (__params, pchar))
        {
          TASK_SET_OUTPUT_PARAM (*__task, pchar,
                                 strdup (assarr_get_value (__params, pchar)));
        }
      else
        {
          TASK_SET_OUTPUT_PARAM (*__task, pchar, strdup (""));
        }
    }
}

/**
 * Print common information to task log file
 *
 * @param __self - task to print information about
 */
static void
print_common_info (wt_task_t *__self)
{
  TASK_LOG (*__self, "-- Common information:\n");
  TASK_LOG (*__self, "    Solution ID : %ld\n", __self->sid);
  TASK_LOG (*__self, "    Problem ID  : %s\n",
            (char*) assarr_get_value (__self->input_params, "PROBLEMID"));
  TASK_LOG (*__self, "    Compiler ID : %s\n",
            (char*) assarr_get_value (__self->input_params, "COMPILERID"));
  TASK_LOG (*__self, "    TESTS       : %s\n",
            (char*) assarr_get_value (__self->input_params, "TESTS"));
  TASK_LOG (*__self, "\n");
}

/**
 * Checks for required input params
 *
 * @param __self - task to check
 * @param __err - buffer to store error
 * @return TRUE on successm FALSE otherwise
 */
static BOOL
check_required_params (wt_task_t *__self, char *__err)
{
  BOOL res = TRUE;
  int i = 0;
  char *cur;

  /* Initialization */
  strcpy (__err, "");

  cur = required_params[i];
  while (cur)
    {
      if (!TASK_INPUT_PARAM (*__self, cur))
        {
          push_string (cur, ", ", __err);
          res = FALSE;
        }
      cur = required_params[++i];
    }

  return res;
}

/**
 * Unlink all unwanted testing dirs
 */
static void
unlink_unwanted_testing_dirs (void)
{
  static BOOL initialized = FALSE;
  static timeval_t last_unlink;
  timeval_t cur = now ();

  mutex_lock (unlink_mutex);
  INF_DEBUG_LOG ("Start unlinking unwanted dirs\n");

  if (!initialized)
    {
      last_unlink = now ();
      initialized = TRUE;
    }

  if (CHECK_TIME_DELTA (last_unlink, cur, unlink_interval))
    {
      char *cur_dir;
      char lock_file[4096], full[4096];
      int to_delete = 0;
      dynastruc_t *ls;

      mutex_lock (lck_mutex);
      ls = dir_listing (testing_dir);
      mutex_unlock (lck_mutex);

      to_delete = dyna_length (ls) - keep_alive_testdirs;
      if (to_delete < 0)
        {
          to_delete = 0;
        }

      DYNA_FOREACH (ls, cur_dir);
        if (!to_delete)
          {
            DYNA_BREAK;
          }

        snprintf (full, BUF_SIZE (full), "%s/%s", testing_dir, cur_dir);
        snprintf (lock_file, BUF_SIZE (lock_file), "%s/lock", full);

        if (!flock_test (lock_file))
          {
            INF_INFO ("Unlink testing dir %s\n", cur_dir);
            unlinkdir (full);
          }
        else
          {
            INF_DEBUG_LOG ("Skipping unlinking testing dir %s\n", cur_dir);
          }

        to_delete--;
      DYNA_DONE;

      dyna_destroy (ls, dyna_deleter_free_ref_data);
      last_unlink = cur;
    }

  mutex_unlock (unlink_mutex);
  INF_DEBUG_LOG ("Unwanted dirs have been just deleted\n");
}

/**
 * Main testing thread
 */
static void
testing_thread (gpointer __data, gpointer __user_data)
{
  wt_task_t *task = __data;

  char pchar[65536];

  /* Directories for current testing stuff */
  char cur_testing_dir[4096];
  char cur_data_dir[4096];
  char lock_file[4096];

  int points = 0, rc;
  char errors[MAX_TESTS * (MAX_ERRCODE + 1)];
  FILE *stream;

  assarr_t *all_params;

  /* Update status of the task */
  TASK_SET_STATUS (*task, TS_RUNNING);

  INF_DEBUG_LOG ("Started new thread for testing task %ld\n", task->sid);

  all_params = assarr_create ();

  /* Calculating current testing and data directories */
  snprintf (cur_testing_dir, BUF_SIZE (cur_testing_dir),
            "%s/%ld", testing_dir, task->sid);
  snprintf (cur_data_dir, BUF_SIZE (cur_data_dir), "%s/%s/%s", data_dir,
            problems_dir, (char*) TASK_INPUT_PARAM (*task, "PROBLEMID"));

  /* Delete all unwanted data */
  unlinkdir (cur_testing_dir);

  /* Create global testing root. */
  /* Deny reading of this root to deny getting listing of this catalogue */
  /* to executable solutions. */
  fmkdir (testing_dir, 00773);

  /* Create current testing directory */
  mutex_lock (lck_mutex);
  snprintf (lock_file, BUF_SIZE (lock_file), "%s/lock", cur_testing_dir);
  fmkdir (cur_testing_dir, 00777);
  flock_set (lock_file);
  mutex_unlock (lck_mutex);

  /* Some initialization */
  points = 0;
  strcpy (errors, "");

  /* Start logging */
  print_common_info (task);

  /*
   * TODO: Add TASK_SET_RESULT_MESSAGE() in case of testing crash
   */

  INF_DEBUG_LOG ("Task %ld. Check for required parameters\n", task->sid);

  /* Check for required data */
  if (!check_required_params (task, pchar))
    {
      strcpy (errors, "CR");
      TASK_LOG (*task, "\n========\n"
                       "Fatal error: Required params aren't defined: %s! "
                       "Testing aborted.\n", pchar);
      REPORT (all_params, "Required params aren't defined: %s.", pchar);
      goto __done_;
    }

  /****
   * TESTING STUFF
   */

  /*
   * Step 0: Saving solution source to file
   */

  INF_DEBUG_LOG ("Task %ld. Step 0: Save solution\n", task->sid);

  if (!save_solution (task, cur_testing_dir))
    {
      strcpy (errors, "CR");
      TASK_LOG (*task, "\n========\nFatal error: unable to save solution! "
                        "Testing aborted.\n");
      REPORT (all_params, "Error saving solution.");
      goto __done_;
    }

  /*
   * Step 1: Compiling colution
   */
  INF_DEBUG_LOG ("Task %ld. Step 1: Compile solution\n", task->sid);

  rc = compile_solution (task, cur_testing_dir, cur_data_dir, all_params);

  TESTING_CHECK_ACTIVE;

  if (rc < 0)
    {
      /* Fatal errors while compile */
      INF_DEBUG_LOG ("[EE] Task %ld. Ctirical error during solution "
                     "compilation process\n");
      points = 0;
      strcpy (errors, "CR");
      TASK_LOG (*task, "\n========\nFatal error while compiling solution. "
                       "Testing aborted.\n");
      goto __done_;
    }

  if (!rc)
    {
      /* Simple compilation error */
      points = 0;
      strcpy (errors, "CE");
      goto __done_;
    }

  /*
   * Step 2: Exec solution at all tests
   */
  testing_main_loop (task, cur_data_dir, cur_testing_dir,
                     &points, errors, all_params);

  TESTING_CHECK_ACTIVE;

__done_:

  /* Updating avaliable parameters */
  snprintf (pchar, BUF_SIZE (pchar), "%d", points);
  assarr_set_value (all_params, "POINTS", strdup (pchar));
  assarr_set_value (all_params, "ERRORS", strdup (errors));

  /* Set output parameters for WebInterface */
  set_output_params (task, all_params);

  /* Some uinitialization */
  assarr_destroy (all_params, assarr_deleter_free_ref_data);

  if (strcmp (errors, "OK"))
    {
      snprintf (pchar, BUF_SIZE (pchar), "Points: %d. Errors: %s",
                points, errors);
    }
  else
    {
      int bonus = atoi (TASK_INPUT_PARAM (*task, "BONUS"));
      snprintf (pchar, BUF_SIZE (pchar), "Points: %d. Bonus: %d",
                points - bonus, bonus);
    }
  TASK_SET_RESULT_MESSAGE (*task, pchar);

  if (strcmp (errors, "CE") && strcmp (errors, "CR"))
    {
      TASK_LOG (*task, "\n========\nTesting completed: %s\n", pchar);
    }

  /* Save log */
  snprintf (pchar, BUF_SIZE (pchar), "%s/%s",
            cur_testing_dir, SOLUTION_ERRORS_LOG);
  stream = fopen (pchar, "w");
  if (stream)
    {
      fprintf (stream, "%s", log_banner);
      TASK_LOG_FLUSH (*task, stream);
      fclose (stream);
    }
  chmod (pchar, 00660);

  INF_DEBUG_LOG ("Task %ld tested\n", task->sid);

  /* Now task is completely tested */
  TASK_SET_STATUS (*task, TS_FINISHED);

  goto __all_done_;

__free_:
  assarr_destroy (all_params, assarr_deleter_free_ref_data);
  TASK_SET_STATUS (*task, TS_INTERRUPTED);

__all_done_:
  flock_clear (lock_file);

  unlink_unwanted_testing_dirs ();

  INF_DEBUG_LOG ("Leave testing thread\n");
}

/**
 * Read data from config file
 */
static void
read_config (void)
{
  double t = 0;
  char dummy[1024];

  INF_INT_KEY (checker_memory_limit, "Checker/Limits/RSS");

  INF_FLOAT_KEY (t, "Checker/Limits/Time");
  checker_time_limit = t * USEC_COUNT;

  INF_INT_KEY (t, "MaxThreads");
  if (t > 0)
    {
      max_threads = t;
    }

  INF_PCHAR_KEY (testing_dir, "TestingDir");
  INF_PCHAR_KEY (data_dir, "DataDir");
  INF_PCHAR_KEY (problems_dir, "ProblemsDir");

  INF_SAFE_PCHAR_KEY (source_file, "SourceFile", INFORMATICS_SOURCE);
  INF_SAFE_PCHAR_KEY (file_to_exec, "FileToExec", INFORMATICS_EXEC);

  /* Tests' files extensions  */
  INF_SAFE_PCHAR_KEY (tst_ext, "Tests/InputExtension", INFORMATICS_TSTEXT);
  INF_SAFE_PCHAR_KEY (ans_ext, "Tests/OutputExtension", INFORMATICS_ANSEXT);

  INF_SAFE_PCHAR_KEY (checker_cmd_template, "Checker/Command", "");

  INF_INT_KEY (unlink_interval, "UnlinkInterval");
  INF_INT_KEY (keep_alive_testdirs, "KeepAliveTestdirs");

  INF_PCHAR_KEY (dummy, "ChRoot");
  use_chroot = is_truth (dummy);

  INF_SAFE_INT_KEY (max_output_store_size, "MaxOutputStoreSize", 0);
}

/**
 * Greate pool for testing threads
 */
static void
create_testing_pool (void)
{
  pool = g_thread_pool_new (testing_thread, NULL, max_threads, FALSE, NULL);
}

/******
 * User's backend
 */

/**
 * Initialize testing stuff
 *
 * @return TRUE on success, FALSE otherwise
 */
BOOL
Informatics_init_testing (void)
{
  read_config ();

  active = mutex_create ();
  unlink_mutex = mutex_create ();
  suspended = mutex_create ();
  lck_mutex = mutex_create ();

  create_testing_pool ();

  mutex_lock (active);

  return TRUE;
}

/**
 * Uninitialize testing stuff
 */
void
Informatics_done_testing (void)
{
  Informatics_stop_testing (0, 0);
  if (active)
    {
      mutex_free (active);
    }

  if (unlink_mutex)
    {
      mutex_free (unlink_mutex);
    }

  if (suspended)
    {
      mutex_free (suspended);
    }

  if (lck_mutex)
    {
      mutex_free (lck_mutex);
    }

  if (pool)
    {
      g_thread_pool_free (pool, FALSE, FALSE);
    }
}

/**
 * Wait for stopping all testing threads
 *
 * @return zero on success, non-zero otherwise
 */
int
Informatics_stop_testing (void *__unused, void *__call_unused)
{
  if (!active || !pool)
    {
      return -1;
    }

  if (mutex_trylock (active))
    {
      mutex_unlock (active);
      return -1;
    }

  /* IMHO it is the best way to wait for all threads is finished */
  mutex_unlock (active);
  g_thread_pool_free (pool, FALSE, TRUE);
  create_testing_pool ();

  return 0;
}

/**
 * Creates new testing thread
 *
 * @param __task - task to be tested
 * @param __error - error description
 * @return TRUE on success, FALSE otherwise
 */
BOOL
Informatics_start_testing_thread (wt_task_t *__task, char *__error)
{
  /* Try to lock `suspended` to make shure stuff is not suspended */
  mutex_lock (suspended);
  /* if locking is completed, unlock `suspended` */
  mutex_unlock (suspended);

  if (mutex_trylock (active))
    {
      strcpy (__error, "Testing stuff is not active");
      mutex_unlock (active);
      return FALSE;
    }

  INF_DEBUG_LOG ("Staring testing thread for task %ld\n", __task->sid);

  if (g_thread_pool_get_num_threads (pool) >= max_threads)
    {
      INF_DEBUG_LOG ("Staring testing thread for task %ld failed: "
                     "pool is full. Continue waiting in queue\n", __task->sid);
      strcpy (__error, "Testing pool is full");
      TASK_SET_FLAG (*__task, TF_KEEPINQUEUE);
      return FALSE;
    }

  INF_DEBUG_LOG ("Pushing testing thread for task %ld\n", __task->sid);
  g_thread_pool_push (pool, __task, 0);

  return TRUE;
}

/**
 * Suspend all testing
 *
 * @return zero on success, non-zero otherwise
 */
int
Informatics_SuspendTesting (void)
{
  mutex_lock (suspended);

  /* It the simpliest way to free pool */
  g_thread_pool_free (pool, FALSE, TRUE);
  create_testing_pool ();

  return 0;
}

/**
 * Resume testing
 *
 * @return zero on success, non-zero otherwise
 */
int
Informatics_ResumeTesting (void)
{
  mutex_unlock (suspended);
  return 0;
}
